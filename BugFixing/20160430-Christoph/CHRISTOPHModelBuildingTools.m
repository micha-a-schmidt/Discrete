(* ::Package:: *)

(* The package `Discrete' is written for Mathematica 8 and is distributed under the
terms of GNU Public License http://www.gnu.org/copyleft/gpl.html *)


BeginPackage["Discrete`ModelBuildingTools`"];

$MBGAP="~/discrete/gap4r8/bin/gap.sh";
If[$OperatingSystem=="MacOSX",$MBGAP="/Applications/gap4r4/bin/gap.sh";];
$MBGAP::usage="$MBGAP defines how to call GAP.";

$MBPATH=DirectoryName[FindFile["Discrete`ModelBuildingTools`"]];
$MBPATH::usage="$MBPATH contains the path to the Mathematica package. Do not change it, unless you know what you are doing.";
    			
$MBVerbose=True;
$MBVerbose::usage="$MBVerbose can be used to globally control the messages of the package. If it is set to True, all messages will be printed, while they are not, if it is set to False. The default is True.";

ClearAll[MBloadGAPGroup];
MBloadGAPGroup::usage="MBloadGAPGroup[Name,Options] loads the group Name with the help of GAP";
SyntaxInformation[MBloadGAPGroup]= {"ArgumentsPattern" -> {_,_.}};
Options[MBloadGAPGroup]={"NumericalEvaluate"->False,"CheckUnitarity"->False};

ClearAll[MBloadGAPSmallGroup];
MBloadGAPSmallGroup::usage="MBloadGAPSmallGroup[Order,Index,Options] loads SmallGroup(Order,Index) with the help of GAP";
SyntaxInformation[MBloadGAPSmallGroup]= {"ArgumentsPattern" -> {_,_,_.}};
Options[MBloadGAPSmallGroup]=Options[MBloadGAPGroup];

ClearAll[MBloadGeneratedGAPGroup];
MBloadGeneratedGAPGroup::usage="MBloadGeneratedGAPGroup[List,Options] loads the group generated by the elements given in List with the help of GAP";
SyntaxInformation[MBloadGeneratedGAPGroup]= {"ArgumentsPattern" -> {_,_.}};
Options[MBloadGeneratedGAPGroup]=Options[MBloadGAPGroup];

ClearAll[MBloadGroupManually];
MBloadGroupManually::usage="MBloadGroupManually[Name,RepMatrices,Options] defines a group via its representation matrices RepMatrices and gives it the name Name";
SyntaxInformation[MBloadGroupManually]= {"ArgumentsPattern" -> {_,_,_.}};
Options[MBloadGroupManually]={"NumericalEvaluate"->False,"CheckUnitarity"->False};

ClearAll[MBgetStructureDescription];
MBgetStructureDescription::usage="MBgetStructureDescription[Group] returns the StructureDescription of Group";
SyntaxInformation[MBgetStructureDescription]= {"ArgumentsPattern" -> {_}};

ClearAll[MBgetRepMatrices];
MBgetRepMatrices::usage="MBgetRepMatrices[Group,p] returns the matrices forming representation p of Group";
SyntaxInformation[MBgetRepMatrices]= {"ArgumentsPattern" -> {_,_}};

ClearAll[MBgetSizeOfGroup];
MBgetSizeOfGroup::usage="MBgetSizeOfGroup[Group] returns the size of Group";
SyntaxInformation[MBgetSizeOfGroup]= {"ArgumentsPattern" -> {_}};

ClearAll[MBgetDimensionOfRep];
MBgetDimensionOfRep::usage="MBgetDimensionOfRep[Group,p] returns the dimension of representation p of Group";
SyntaxInformation[MBgetDimensionOfRep]= {"ArgumentsPattern" -> {_,_}};

ClearAll[MBgetDimensionsOfReps];
MBgetDimensionsOfReps::usage="MBgetDimensionOfReps[Group] returns the dimensions of all representations Group";
SyntaxInformation[MBgetDimensionsOfReps]= {"ArgumentsPattern" -> {_}};

ClearAll[MBgetNumberOfReps];
MBgetNumberOfReps::usage="MBgetNumberOfReps[Group] returns the number of irreducible representations of Group";
SyntaxInformation[MBgetNumberOfReps]= {"ArgumentsPattern" -> {_}};


(* function operating on characters *)

ClearAll[MBgetCharacterTable];
MBgetCharacterTable::usage="MBgetCharacterTable[Group] returns the character table";
SyntaxInformation[MBgetCharacterTable]= {"ArgumentsPattern" -> {_}};

ClearAll[MBgetCharacterProduct];
MBgetCharacterProduct::usage="MBgetCharacterProduct[Group,Character1,Character2] returns the scalar product of the two given characters which can be either vectors or the number of the representation";
SyntaxInformation[MBgetCharacterProduct]= {"ArgumentsPattern" -> {_,_,_}};

ClearAll[MBgetMultiplicity];
MBgetMultiplicity::usage="MBgetMultiplicity[Group,p,q,r] returns the multiplicity or irrep r within the Kroneckerproduct p x q of Group";
SyntaxInformation[MBgetMultiplicity]= {"ArgumentsPattern" -> {_,_,_,_}};

ClearAll[MBgetKroneckerProduct];
MBgetKroneckerProduct::usage="MBgetKroneckerProduct[Group,p,q] returns the multiplicities of the irreps in the Kroneckerproduct p x q of Group";
SyntaxInformation[MBgetKroneckerProduct]= {"ArgumentsPattern" -> {_,_,_}};

ClearAll[MBisUnitaryRep];
MBisUnitaryRep::usage="MBisUnitaryRep[Group,p] checks whether irrep p of group Group is unitary.";
SyntaxInformation[MBisUnitaryRep]={"ArgumentsPattern"->{_,_}};

ClearAll[MBisUnitary];
MBisUnitary::usage="MBisUnitary[Group] checks whether all irreducible representations of group Group are unitary.";
SyntaxInformation[MBisUnitary]={"ArgumentsPattern"->{_}};

 
(* functions involving Clebsch-Gordan coefficient *)

ClearAll[MBJoin];
MBJoin::usage="MBJoin[A,B] combines A and B, MBJoin[List] combines all elements of the List";
SyntaxInformation[MBJoin]= {"ArgumentsPattern" -> {_,_.}};

ClearAll[MBUnion];
MBUnion::usage="MBUnion[A,B] combines A and B and removes all duplicates, MBUnion[List] combines all elements of List and removes all duplicates";
SyntaxInformation[MBUnion]= {"ArgumentsPattern" -> {_,_.}};

ClearAll[MBgetRepVector];
MBgetRepVector::usage="MBgetRepVector[Group,Rep,Head] returns a vector of representation Rep suitable for MBmultiply with variables starting with Head,
MBgetRepVector[Group,List] returns a vector of a reducible representation suitable for MBmultiply where List is a list of pairs (Rep, Label), where Rep denotes the representation and Label labels the components. MBgetRepVector[Group] returns a list with one empty list for each representation.";
SyntaxInformation[MBgetRepVector]= {"ArgumentsPattern" -> {_,_.,_.}};

ClearAll[MBextractOneRep];
MBextractOneRep::usage="MBextractOneRep[RepVector,NumRep,nthRep] extracts the nth irreducible representation NumRep from RepVector. nthRep is optional. If nthRep is not given, all representations NumRep are returned.";
SyntaxInformation[MBextractOneRep]={"ArgumentsPattern"->{_,_,_.}};


ClearAll[MBgetCGC];
MBgetCGC::usage="MBgetCGC[Group,p,q] returns the Clebsch Gordan coefficients for the Kroneckerproduct p x q of Group in form of the unitary matrix U: i.e. Subscript[\[CapitalGamma], p] * Subscript[\[CapitalGamma], q] U = U Subscript[\[CapitalSigma], r] n(p,q;r) Subscript[\[CapitalGamma], r]";
SyntaxInformation[MBgetCGC]= {"ArgumentsPattern" -> {_,_,_}};

ClearAll[MBgetCGCcc];
MBgetCGCcc::usage="MBgetCGCcc[Group,p,q] returns the hermitean conjugate of the CG coefficients for the Kroneckerproduct p x q of Group: i.e. U^\[Dagger] :\[CapitalGamma]p \[Times] \[CapitalGamma]q U = U \[Sigma] n(p,q;r) \[CapitalGamma]r";
SyntaxInformation[MBgetCGCcc]= {"ArgumentsPattern" -> {_,_,_}};

ClearAll[MBmultiply];
MBmultiply::usage="MBmultiply[Group,A,B] multiplies A and B using the CG coefficients of Group.\n
MBmultiply[Group,List] multiplies all elements in List using the CG coefficients of Group.";
SyntaxInformation[MBmultiply]= {"ArgumentsPattern" -> {_,_,_.}};

ClearAll[MBgetCovariants];
MBgetCovariants::usage="MBgetCovariants[Group, Reps, Order] returns all covariants of Reps up to order Order using the CG coefficients of Group.";
SyntaxInformation[MBgetCovariants]= {"ArgumentsPattern" -> {_,_,_}};

ClearAll[MBgetFlavonPotential];
MBgetFlavonPotential::usage="MBgetFlavonPotential[Group, Reps, Order, Head] returns the summed up invariants formed by Reps up to order Order using the CG coefficients of Group. The prefix of the couplings is Head.";
SyntaxInformation[MBgetFlavonPotential]= {"ArgumentsPattern" -> {_,_,_,_}};

ClearAll[MBgetMassMatrix];
MBgetMassMatrix::usage="MBgetMassMatrix[Group,Left,Right,Flavon,Order,M,Y] generates the mass matrix m_{ij} L_i R_j of with the fields Left L_i and the Right R_j up to order Order (default: 1) in the flavons Flavon with direct mass term M and Yukawa couplings starting with Y. The flavons are given as a list of representations, while Left/Right are ordered lists of representations.";
SyntaxInformation[MBgetMassMatrix]= {"ArgumentsPattern" -> {_,_,_,_,_.,_.,_.}};

ClearAll[MBgetMajoranaMassMatrix];
MBgetMajoranaMassMatrix::usage="MBgetMajoranaMassMatrix[Group,Fermion,Flavon,Order,M,Y] generates the Majorana mass matrix m_{ij} F_i F_j of with the fields Fermion F_i up to order Order (default: 1) in the flavons Flavon with direct mass term M and Yukawa couplings starting with Y. The flavons are given as a list of representations, while Fermion is an ordered list of representations.";
SyntaxInformation[MBgetMajoranaMassMatrix]= {"ArgumentsPattern" -> {_,_,_,_.,_.,_.}};

ClearAll[MBconvertGAPToMathematica];
MBconvertGAPToMathematica::usage="MBconvertGAPToMathematica[String] converts String from GAP format to Mathematica Input format.";
SyntaxInformation[MBconvertGAPToMathematica] = {"ArgumentsPattern" -> {_}};

ClearAll[MBconvertMathematicaToGAP];
MBconvertMathematicaToGAP::usage="MBconvertMathematicaToGAP[Expression] converts Expression from Mathematica to GAP format.";
SyntaxInformation[MBconvertMathematicaToGAP] = {"ArgumentsPattern" -> {_}};


ClearAll[MBsimplifyCovariants];
MBsimplifyCovariants::usage="MBsimplifyCovariants[Operators] reduces a set of operators Operators.";
SyntaxInformation[MBsimplifyCovariants]= {"ArgumentsPattern" -> {_}};

Begin["`Private`"];

(* Internal functions *)
ClearAll[MBgetPotentialFromList]
MBgetPotentialFromList::usage="MBgetPotentialFromList[List, Coeff1, Coeff2] takes a list List and adds all terms in the list with coefficients starting with Coeff1 Coeff2"; 
SyntaxInformation[MBgetPotentialFromList]= {"ArgumentsPattern" -> {_,_,_}};

ClearAll[MBgetYukawasFromList]
MBgetYukawasFromList::usage="MBgetYukawasFromList[List, Coeff1, Coeff2] takes a list List and adds all terms in the list with coefficients starting with Coeff1 Coeff2"; 
SyntaxInformation[MBgetYukawasFromList]= {"ArgumentsPattern" -> {_,_,_}};


ClearAll[MonomialQ];
MonomialQ::usage="MonomialQ[Expression] checks whether Expression is made of monomials only.";
ClearAll[SplitMonoPoly];
SplitMonoPoly::usage="SplitMonoPoly[Operators] splits the list of operators in two sublists of Monomials and Polynomials.";
ClearAll[ExtractNumbers];
ExtractNumbers::usage="ExtractNumbers[Expression] extracts all numbers of Expression.";
ClearAll[ExtractMonomial];
ExtractMonomial::usage="ExtractMonomial[List] extracts all monomials of List";
ClearAll[ExtractAllMonomials];
ExtractAllMonomials::usage="ExtractAllMonomials[Expression] extracts all monomials of Expression.";
ClearAll[NormalizeMonomial];
NormalizeMonomial::usage="NormalizeMonomial[Expression] normalizes the monomial in Expression.";
ClearAll[NormalizePolynomial];
NormalizePolynomial::usage="NormalizePolynomial[Expression] normalizes the polynomial in Expression.";
ClearAll[ReduceMonomials];
ReduceMonomials::usage="ReduceMonomials[Expression] removes all monomials in Expression which differ only by the normalization.";
ClearAll[ReducePolynomialUsingMonomial];
ReducePolynomialUsingMonomial::usage="ReducePolynomialUsingMonomial[Polynomial,Monomial] reduces the polynomial Polynomial by subtracting a suitable Monomial.";
ClearAll[ReducePolynomialUsingMonomials];
ReducePolynomialUsingMonomials::usage="ReducePolynomialUsingMonomials[Polynomial,Monomials] reduces the polynomial Polynomial by subtracting suitable monomials in Monomials.";
ClearAll[ReducePolynomials];
ReducePolynomials::usage="ReducePolynomials[Polynomials,Monomials] reduces all polynomials in Polynomials by means of the function ReducePolynomialUsingMonomials";
ClearAll[GaussElimPolynomials];
GaussElimPolynomials::usage="GaussElimPolynomials[Polynomial] applies the Gauss elimination procedure to Polynomial in order to simplify.";
ClearAll[ReduceMonoPolySimple];
ReduceMonoPolySimple::usage="ReduceMonoPolySimple[{Monomials,Polynomials}] applies basic reductions to the set of Monomials and Polynomials.";
ClearAll[ReduceOperators];
ReduceOperators::usage="ReduceOperators[Operators] reduces Operators to a simpler basis.";
ClearAll[VectorZeroQ];
VectorZeroQ::usage="VectorZeroQ[expr] checks whether the list expr is a list of zeros";
ClearAll[ExtractVars];
ExtractVars::usage="ExtractVars[expr] extracts the variables from expr.";
ClearAll[mIndex];
mIndex::usage="mIndex[q,i,j] returns the index into the CG coefficients."
ClearAll[mTensorProduct];
mTensorProduct::usage="mTensorProduct[p,q] calculates the tensor product of two lists.";
ClearAll[pickTuple];
pickTuple::usage="pickTuple[r,p,q,A,start] picks a tuple in the algorithm to calculate Clebsch Gordan coefficients.";
ClearAll[A];
A::usage="A[Group,r,p,q,l,k] calculates the tensor A in the algorithm for calculating CG coefficients.";
ClearAll[getC];
getC::usage="getC[r,p,q,l,q,start] returns C in the algorithm for calculating CG coefficients.";
ClearAll[CGC];
CGC::usage="CGC[Group,p,q] calculates on set of CG coefficients.";
ClearAll[getCNormalized];
getCNormalized::usage="getCNormalized[r,p,q,l,A] returns a normalized version of C";
ClearAll[CGCUnitary];
CGCUnitary::usage="CGCUnitary[Group,p,q] returns unitary CG coefficients.";
ClearAll[decomposeTensorProduct];
decomposeTensorProduct::usage="decomposeTensorProduct[Group,p,q,vec] decomposes the tensor product of representations p and q.";
ClearAll[genCoefficients];
genCoefficients::usage="genCoefficients[number,head,end] generates number coefficients starting with head and ending with end.";
ClearAll[genLabels];
genLabels::usage="genLabels[number,head] generates number labels starting with head."; 
ClearAll[generateKroneckerProduct];
generateKroneckerProduct::usage="generateKroneckerProduct[Group,p,q] calculates the Kronecker product of p with q.";
ClearAll[genTempName];
genTempName::usage="genTempName[] returns a temporary filename.";
ClearAll[readGAP];
readGAP::usage="readGAP[filename] reads in a GAP output file.";
ClearAll[HC];
HC::usage="HC[expr] returns the hermitian conjugate of expr.";
ClearAll[plusHC];
plusHC::usage="plusHC[expr] returns expr + HC[expr]."



(* Definition of functions *)


MBgetCGC[pGroup_,p_,q_]:=Block[{},
	If[!ValueQ[pGroup["CGcoeff"][p,q]],
		If[pGroup["UnitaryRepresentations"],
			pGroup["CGcoeff"][p,q]=CGCUnitary[pGroup,p,q],
			pGroup["CGcoeff"][p,q]=CGC[pGroup,p,q];
		];
	];
	Return[pGroup["CGcoeff"][p,q]];	
];

MBgetCGCcc[pGroup_,p_,q_]:=If[pGroup["UnitaryRepresentations"],
			ConjugateTranspose[MBgetCGC[pGroup,p,q]],
			Inverse[MBgetCGC[pGroup,p,q]];
		];

MaBasis={{{{1}},{{1}},{{1}},{{1}},{{1}},{{1}},{{1}},{{1}},{{1}},{{1}},{{1}},{{1}}},{{{1}},{{-(-1)^(1/3)}},{{1}},{{1}},{{(-1)^(2/3)}},{{-(-1)^(1/3)}},{{-(-1)^(1/3)}},{{1}},{{(-1)^(2/3)}},{{(-1)^(2/3)}},{{-(-1)^(1/3)}},{{(-1)^(2/3)}}},{{{1}},{{(-1)^(2/3)}},{{1}},{{1}},{{-(-1)^(1/3)}},{{(-1)^(2/3)}},{{(-1)^(2/3)}},{{1}},{{-(-1)^(1/3)}},{{-(-1)^(1/3)}},{{(-1)^(2/3)}},{{-(-1)^(1/3)}}},{{{1,0,0},{0,1,0},{0,0,1}},{{0,1,0},{0,0,1},{1,0,0}},{{-1,0,0},{0,1,0},{0,0,-1}},{{-1,0,0},{0,-1,0},{0,0,1}},{{0,0,1},{1,0,0},{0,1,0}},{{0,1,0},{0,0,-1},{-1,0,0}},{{0,-1,0},{0,0,1},{-1,0,0}},{{1,0,0},{0,-1,0},{0,0,-1}},{{0,0,-1},{-1,0,0},{0,1,0}},{{0,0,1},{-1,0,0},{0,-1,0}},{{0,-1,0},{0,0,-1},{1,0,0}},{{0,0,-1},{1,0,0},{0,-1,0}}}};
AFBasis={{{{1}},{{1}},{{1}},{{1}},{{1}},{{1}},{{1}},{{1}},{{1}},{{1}},{{1}},{{1}}},{{{1}},{{-(-1)^(1/3)}},{{1}},{{1}},{{(-1)^(2/3)}},{{-(-1)^(1/3)}},{{-(-1)^(1/3)}},{{1}},{{(-1)^(2/3)}},{{(-1)^(2/3)}},{{-(-1)^(1/3)}},{{(-1)^(2/3)}}},{{{1}},{{(-1)^(2/3)}},{{1}},{{1}},{{-(-1)^(1/3)}},{{(-1)^(2/3)}},{{(-1)^(2/3)}},{{1}},{{-(-1)^(1/3)}},{{-(-1)^(1/3)}},{{(-1)^(2/3)}},{{-(-1)^(1/3)}}},{{{1,0,0},{0,1,0},{0,0,1}},{{1,0,0},{0,(-1)^(2/3),0},{0,0,-(-1)^(1/3)}},{{-(1/3),1/3 I (I+Sqrt[3]),-(1/3)-I/Sqrt[3]},{-(1/3)-I/Sqrt[3],-(1/3),1/3 I (I+Sqrt[3])},{1/3 I (I+Sqrt[3]),-(1/3)-I/Sqrt[3],-(1/3)}},{{-(1/3),-(1/3)-I/Sqrt[3],1/3 I (I+Sqrt[3])},{1/3 I (I+Sqrt[3]),-(1/3),-(1/3)-I/Sqrt[3]},{-(1/3)-I/Sqrt[3],1/3 I (I+Sqrt[3]),-(1/3)}},{{1,0,0},{0,-(-1)^(1/3),0},{0,0,(-1)^(2/3)}},{{-(1/3),1/3 I (I+Sqrt[3]),-(1/3)-I/Sqrt[3]},{2/3,-(1/3) (-1)^(2/3),-(1/3)-I/Sqrt[3]},{2/3,1/3 I (I+Sqrt[3]),1/3 (-1)^(1/3)}},{{-(1/3),-(1/3)-I/Sqrt[3],1/3 I (I+Sqrt[3])},{-(1/3)-I/Sqrt[3],-(1/3) (-1)^(2/3),2/3},{1/3 I (I+Sqrt[3]),2/3,1/3 (-1)^(1/3)}},{{-(1/3),2/3,2/3},{2/3,-(1/3),2/3},{2/3,2/3,-(1/3)}},{{-(1/3),1/3 I (I+Sqrt[3]),-(1/3)-I/Sqrt[3]},{1/3 I (I+Sqrt[3]),1/3 (-1)^(1/3),2/3},{-(1/3)-I/Sqrt[3],2/3,-(1/3) (-1)^(2/3)}},{{-(1/3),-(1/3)-I/Sqrt[3],1/3 I (I+Sqrt[3])},{2/3,1/3 (-1)^(1/3),1/3 I (I+Sqrt[3])},{2/3,-(1/3)-I/Sqrt[3],-(1/3) (-1)^(2/3)}},{{-(1/3),2/3,2/3},{1/3 I (I+Sqrt[3]),-(1/3) (-1)^(2/3),1/3 I (I+Sqrt[3])},{-(1/3)-I/Sqrt[3],-(1/3)-I/Sqrt[3],1/3 (-1)^(1/3)}},{{-(1/3),2/3,2/3},{-(1/3)-I/Sqrt[3],1/3 (-1)^(1/3),-(1/3)-I/Sqrt[3]},{1/3 I (I+Sqrt[3]),1/3 I (I+Sqrt[3]),-(1/3) (-1)^(2/3)}}}};

MBgetRepMatrices[pGroup_,p_]:=AFBasis[[p]];
(*MBgetRepMatrices[pGroup_,p_]:=pGroup["RepMatrices"][[p]];*)

MBgetSizeOfGroup[pGroup_]:=pGroup["Size"];

MBgetDimensionOfRep[pGroup_,p_]:=pGroup["DimensionsOfReps"][[p]];

MBgetDimensionsOfReps[pGroup_]:=pGroup["DimensionsOfReps"];

MBgetNumberOfReps[pGroup_]:=pGroup["NumberOfReps"];

MBgetMultiplicity[pGroup_,p_,q_,r_]:=MBgetKroneckerProduct[pGroup,p,q][[r]];

(*Block[{T},Return[FullSimplify[Simplify[Sum[Tr[MBgetRepMatrices[pGroup,p][[T]]]*Tr[MBgetRepMatrices[pGroup,q][[T]]]*Conjugate[Tr[MBgetRepMatrices[pGroup,r][[T]]]],{T,MBgetSizeOfGroup[pGroup]}]/MBgetSizeOfGroup[pGroup]]]]];*)

MBgetRepVector[pGroup_]:=ConstantArray[{},MBgetNumberOfReps[pGroup]];

MBgetRepVector[pGroup_,pRep_?NumberQ,pHead_]:=Block[{lres},
	lres=MBgetRepVector[pGroup];
	If[pRep>0,lres[[pRep]]={genLabels[MBgetDimensionOfRep[pGroup,pRep],pHead]}];
	Return[lres];
];

MBgetRepVector[pGroup_,pRep_List,pHead_]:=Block[{lres,li},
	lres=MBgetRepVector[pGroup];
	For[li=1,li<=Length[pRep],li++,
		lres[[pRep]]=Append[lres[[pRep]],genLabels[MBgetDimensionOfRep[pGroup,pRep],pHead]];
	];
	Return[lres];
];

MBgetRepVector[pGroup_,pList_]:=MBJoin[Map[MBgetRepVector[pGroup,#[[1]],#[[2]]]&,pList]];


MBextractOneRep[pRepVec_,pNum_]:=ReplacePart[pRepVec,Map[{#}&,Delete[Range[Length[pRepVec]],pNum]]->{}];

MBextractOneRep[pRepVec_,pNum_,pnth_]:=Block[{res},
	res=MBextractOneRep[pRepVec,pNum];
	res[[pNum]]={res[[pNum,pnth]]};
	Return[res];
];

MBgetStructureDescription[pGroup_]:=pGroup["StructureDescription"];

MBgetCharacterTable[pGroup_]:=pGroup["CharacterTable"];

MBgetCharacterProduct[pGroup_,pChar1_?NumberQ,pChar2_?NumberQ]:=
FullSimplify[Simplify[pGroup["CharacterTable"][[pChar1]].Conjugate[pGroup["CharacterTable"][[pChar2]]*pGroup["SizeConjugacyClasses"]]/pGroup["Size"]]];

MBgetCharacterProduct[pGroup_,pChar1_List,pChar2_?NumberQ]:=
FullSimplify[Simplify[pChar1.Conjugate[pGroup["CharacterTable"][[pChar2]]*pGroup["SizeConjugacyClasses"]]/pGroup["Size"]]];

MBgetCharacterProduct[pGroup_,pChar1_?NumberQ,pChar2_List]:=
FullSimplify[Simplify[pGroup["CharacterTable"][[pChar1]].Conjugate[pChar2*pGroup["SizeConjugacyClasses"]]/pGroup["Size"]]];

MBgetCharacterProduct[pGroup_,pChar1_List,pChar2_List]:=
FullSimplify[Simplify[pChar1.Conjugate[pChar2*pGroup["SizeConjugacyClasses"]]/pGroup["Size"]]];


MBgetKroneckerProduct[pGroup_,p_,q_]:=Block[{},
	If[!ValueQ[pGroup["KroneckerProduct"][p,q]],
		pGroup["KroneckerProduct"][p,q]=generateKroneckerProduct[pGroup,p,q]
		];
	Return[pGroup["KroneckerProduct"][p,q]];	
];

MBJoin[pX_, pY_] := Block[{li}, Table[Join[pX[[li]], pY[[li]]], {li, Length[pX]}]];
MBJoin[pList_]:=Fold[Function[{x,y},MBJoin[x,y]],pList[[1]],Delete[pList,1]];

MBUnion[pX_, pY_] := Block[{li}, Table[Union[pX[[li]], pY[[li]]], {li, Length[pX]}]];
MBUnion[pList_]:=Fold[Function[{x,y},MBUnion[x,y]],pList[[1]],Delete[pList,1]];


MBloadGAPSmallGroup[pOrder_,pIndex_,pOptions:OptionsPattern[]]:=MBloadGAPGroup["SmallGroup("<>ToString[pOrder]<>","<>ToString[pIndex]<>")",pOptions];

MBloadGeneratedGAPGroup[pList_,pOptions:OptionsPattern[]]:=MBloadGAPGroup[StringJoin["Group(",MBconvertMathematicaToGAP[pList],")"],pOptions];

MBloadGAPGroup[pName_,OptionsPattern[]]:=Module[{Group},
			Block[{f,p,q,OUTPUT,INPUT,PATH2,TEMPFILES},
				Group["Name"]=pName;
    			PATH2=$TemporaryPrefix;
                TEMPFILES=PATH2<>genTempName[];
                OUTPUT=TEMPFILES<>"_OUTPUT.m";
                INPUT=TEMPFILES<>"_INPUT.g";
                f = OpenWrite[INPUT, {FormatType -> OutputForm, PageWidth -> Infinity}];
			    Write[f,"Read(\""<>$MBPATH<>"extractGroupData.gap\");;\nMBgetGroupInfo(" <> Group["Name"]<>",\""<>OUTPUT<>"\");;\nquit;;\n^D^D\n"];
			    Close[f];
                If[$MBVerbose,Print["starting GAP generating "<>Group["Name"]<>"..."]];
                Run["cat "<>INPUT<>" | "<>$MBGAP<> " -b -q "];
                If[$MBVerbose,Print["...finished"]];
			    f=StringToStream[readGAP[OUTPUT]];
			    Group["StructureDescription"]=Read[f,Expression];
			    If[$MBVerbose,Print["\nStructureDescription:",Group["StructureDescription"],"\n"]];
			    Group["Size"]=Read[f,Expression];
			    If[$MBVerbose,Print["Size of Group:",Group["Size"],"\n"]];
			    Group["DimensionsOfReps"]=Read[f,Expression];
			    Group["NumberOfReps"]=Length[Group["DimensionsOfReps"]];
			    If[$MBVerbose,Print["Number of irreps: ",Group["NumberOfReps"],"\n"]];
			    If[$MBVerbose,Print["Dimensions of irreps:\n",TableForm[{Range[Group["NumberOfReps"]],Group["DimensionsOfReps"]}],"\n"]];
			    Group["SizeConjugacyClasses"]=Read[f,Expression];
			    Group["CharacterTable"]=Read[f,Expression];
			    If[$MBVerbose,Print["Character Table:\n",TableForm[Group["CharacterTable"]],"\n"]];
			    Group["RepMatrices"]=FullSimplify[Simplify[Read[f,Expression]]];
			    Group["NumericalEvaluate"]=OptionValue["NumericalEvaluate"];
			    If[!($OperatingSystem=="MacOSX"),DeleteFile[{INPUT, OUTPUT}];];
			    Group["UnitaryRepresentations"]=True;
                If[OptionValue["CheckUnitarity"],
                	If[$MBVerbose,Print["checking unitarity..."]];
			    	Group["UnitaryRepresentations"]=MBisUnitary[Group];
			    	If[!Group["UnitaryRepresentations"],If[$MBVerbose,Print["There are representations which are not unitary.\n"]]];
			    	];
			    ];	
			  	  Return[Group];
			    ];

MBloadGroupManually[pName_,pRepMatrices_,OptionsPattern[]]:=Module[{Group},
			Block[{ltemp,lpos},
				Group["Name"]=pName;
    			Group["StructureDescription"]=pName;
			    Group["RepMatrices"]=pRepMatrices;
			    Group["Size"]=Length[pRepMatrices[[1]]];
			    If[$MBVerbose,Print["Size of Group:",Group["Size"],"\n"]];
			    Group["DimensionsOfReps"]=Map[Length[#[[1]]]&,Group["RepMatrices"]];
			    Group["NumberOfReps"]=Length[Group["RepMatrices"]];
			    If[$MBVerbose,Print["Number of irreps: ",Group["NumberOfReps"],"\n"]];
			    If[$MBVerbose,Print["Dimensions of irreps:\n",TableForm[{Range[Group["NumberOfReps"]],Group["DimensionsOfReps"]}],"\n"]];
			    ltemp=Sort[Map[{Length[#],First[#]}&,Gather[Map[Map[Tr,#]&,Transpose[Group["RepMatrices"]]]]]];
			    ltemp=Prepend[Delete[ltemp,Position[ltemp,{1,Group["DimensionsOfReps"]}]],{1,Group["DimensionsOfReps"]}];
			    Group["SizeConjugacyClasses"]=Map[First,ltemp];
			    Group["CharacterTable"]=Transpose[Map[Last,ltemp]];
			    If[$MBVerbose,Print["Character Table:\n",TableForm[Group["CharacterTable"]],"\n"]];
			    Group["NumericalEvaluate"]=OptionValue["NumericalEvaluate"];
			    Group["UnitaryRepresentations"]=True;
                If[OptionValue["CheckUnitarity"],
                	If[$MBVerbose,Print["checking unitarity..."]];
			    	Group["UnitaryRepresentations"]=MBisUnitary[Group];
			    	If[!Group["UnitaryRepresentations"],If[$MBVerbose,Print["There are representations which are not unitary.\n"]]];
			    	];
			    ];	
			  	Return[Group];
			    ];

MBisUnitaryRep[pGroup_,pRep_]:=Block[{ltemp},
	ltemp=False;
	If[pGroup["NumericalEvaluate"],
		ltemp=Union[N[FullSimplify[Simplify[Map[N[ConjugateTranspose[#].#]&,pGroup["RepMatrices"][[pRep]]]]]]],
		ltemp=Union[FullSimplify[Simplify[Map[ConjugateTranspose[#].#&,pGroup["RepMatrices"][[pRep]]]]]]
	];
	Return[Length[ltemp]==1 \[And] ltemp[[1]]==IdentityMatrix[Length[ltemp[[1]]]]];
	];

MBisUnitary[pGroup_]:=Block[{li},
	For[li=1,li<=MBgetNumberOfReps[pGroup],li++,
		If[!MBisUnitaryRep[pGroup,li],Return[False]];
	];
	Return[True];
	];



MBmultiply[pGroup_,pList_]:=Fold[Function[{x,y},MBmultiply[pGroup,x,y]],pList[[1]],Delete[pList,1]];


ClearAll[MBmultOneRep];
MBmultOneRep[pGroup_,li_,lj_,pA_,pB_]:=Block[{x,y},Return[Map[Function[y,Map[Function[x,decomposeTensorProduct[pGroup,li, lj, Simplify[MBgetCGCcc[pGroup,li, lj].mTensorProduct[x,y]]]],pA[[li]]]],pB[[lj]]]];];

MBmultiply[pGroup_,pA_, pB_] := 
  Block[{li, lj, lm, ln, lk, ll, lp, lres, lrep, ltemp},
   lres = Table[{}, {li, Length[pA]}];
   If[pA === lres, Return[pB]];
   If[pB === lres, Return[pA]];
   For[li = 1, li <= Length[pA], li++,
    For[lj = 1, lj <= Length[pB], lj++,
      lres=MBJoin[Append[Flatten[If[li>lj,MBmultOneRep[pGroup,lj,li,pB,pA],MBmultOneRep[pGroup,li,lj,pA,pB]],1],lres]];
      ];
    ];
   Return[Map[Union, lres]];
];



MBgetCovariants[pGroup_,pReps_, pOrder_, pAssumptions___] :=
  Block[{li, lres, ltemp},
	 lres=Table[{},{li,pOrder}];
	 lres[[1]] = pReps;
	 For[li = 2, li <= pOrder, li++,
		If[$MBVerbose,Print[li]];
		lres[[li]] = MBmultiply[pGroup,lres[[li-1]], pReps];
    	lres[[li]] = DeleteCases[Simplify[lres[[li]], pAssumptions], _?VectorZeroQ, 2];
    	lres[[li]] = MBsimplifyCovariants[lres[[li]]];
    	lres[[li]] = DeleteCases[Simplify[lres[[li]], pAssumptions], _?VectorZeroQ, 2];
    ];
   	Return[lres];
];

MBgetFlavonPotential[pGroup_,pReps_, pOrder_, pHead_:"l", pAssumptions___] :=
  Block[{lInvariants,li,lres,ltemp},
  	If[pOrder>1,
	 lInvariants = MBgetCovariants[pGroup,pReps,pOrder-1,pAssumptions];
	 If[$MBVerbose,Print[pOrder]];
	 lInvariants = Append[lInvariants,Prepend[Table[{},{li,Length[pReps]-1}],MBmultiply[pGroup,Last[lInvariants],pReps][[1]]]];
	 lInvariants[[pOrder]] = DeleteCases[Simplify[lInvariants[[pOrder]], pAssumptions], _?VectorZeroQ, 2];
     lInvariants[[pOrder]] = MBsimplifyCovariants[lInvariants[[pOrder]]];
     lInvariants[[pOrder]] = DeleteCases[Simplify[lInvariants[[pOrder]], pAssumptions], _?VectorZeroQ, 2];
	 ,lInvariants = {pReps};
  	];
     (*lInvariants = MBgetCovariants[pGroup,pReps,pOrder,pAssumptions];*)
	     lres = 0;
         For[li = 1, li <= pOrder, li++,
             ltemp=MBgetPotentialFromList[Flatten[lInvariants[[li,1]]], pHead, li];
             (*ltemp=Simplify[ltemp+Conjugate[ltemp]];*)
             lres += ltemp;
         ];
         Return[lres];
	];

MBgetPotentialFromList[pList_, pHead_, pEnd_] := 
  Block[{lres, li, lList, lElem, lElemCC},
   lList = pList;
   lres = 0;
   li = 1;
   While[Length[lList] > 0, lElem = First[lList];
    lList = Delete[lList, 1];
    lElemCC = Simplify[HC[lElem]];
    If[Simplify[lElem === lElemCC], 
    $Assumptions=$Assumptions && Element[ToExpression[StringJoin[ToString[pHead],ToString[pEnd],"n",ToString[li]]],Reals]; 
    lres += Simplify[
       lElem*ToExpression[StringJoin[ToString[pHead],ToString[pEnd],"n",ToString[li]]]],
    $Assumptions=$Assumptions && Element[ToExpression[StringJoin["r",ToString[pHead],ToString[pEnd],"n",ToString[li]]],Reals] && Element[ToExpression[StringJoin["i",ToString[pHead],ToString[pEnd],"n",ToString[li]]],Reals]; 
    lres += 
      Simplify[
       plusHC[lElem*(ToExpression[
            StringJoin["r", ToString[pHead], ToString[pEnd], "n", 
             ToString[li]]] + 
           I*ToExpression[
             StringJoin["i", ToString[pHead], ToString[pEnd], "n", 
              ToString[li]]])]];
     lList = DeleteCases[lList, lElemCC];];
    li++;];
   (*lres=pList.genCoefficients[Length[pList],pHead,pEnd];*)
   Return[lres];];
   
genCoefficients[pLenList_, pHead_, pEnd_] := Block[{lf}, 
  Return[Table[(ToExpression["r"<>
    ToString[pHead] <> ToString[pEnd] <> "n" <> ToString[lf] ]+I ToExpression[
    "i"<>ToString[pHead] <> ToString[pEnd] <> "n" <> ToString[lf] ]), {lf, pLenList}]];];

MBgetYukawasFromList[pList_, pHead_, pEnd_] := 
  Block[{lres, li, lList, lElem, lElemCC},
   lList = pList;
   lres = 0;
   li = 1;
   While[Length[lList] > 0, lElem = First[lList];
    lList = Delete[lList, 1];
    $Assumptions=$Assumptions && Element[ToExpression[StringJoin["r",ToString[pHead],ToString[pEnd],"n",ToString[li]]],Reals] && Element[ToExpression[StringJoin["i",ToString[pHead],ToString[pEnd],"n",ToString[li]]],Reals]; 
    lres += 
      Simplify[
       lElem*(ToExpression[
            StringJoin["r", ToString[pHead], ToString[pEnd], "n", 
             ToString[li]]] + 
           I*ToExpression[
             StringJoin["i", ToString[pHead], ToString[pEnd], "n", 
              ToString[li]]])];
    li++;];
   (*lres=pList.genCoefficients[Length[pList],pHead,pEnd];*)
   Return[lres];];

MBgetMassMatrix[pGroup_,pLeft_,pRight_,pFlavon_,pOrder_:1,pM_:"m",pY_:"y"]:=Block[{lLeft,lRight,lLeftVars,lRightVars,lres,lCovariants,li},
	lLeft=Map[genLabels[MBgetDimensionOfRep[pGroup,#[[1]]],"pL"<>ToString[#[[2]]]<>"n"]&,Transpose[{pLeft,Range[Length[pLeft]]}]];
	lRight=Map[genLabels[MBgetDimensionOfRep[pGroup,#[[1]]],"pR"<>ToString[#[[2]]]<>"n"]&,Transpose[{pRight,Range[Length[pRight]]}]];
	lLeftVars=Flatten[lLeft];
	lRightVars=Flatten[lRight];
	lLeft=DeleteCases[Flatten[Reap[Map[Sow[Apply[Sequence,#]]&,Transpose[{lLeft,pLeft}]];Map[Sow[{},#]&,Range[MBgetNumberOfReps[pGroup]]], Range[MBgetNumberOfReps[pGroup]]][[2]],1],{},2];
	lRight=DeleteCases[Flatten[Reap[Map[Sow[Apply[Sequence,#]]&,Transpose[{lRight,pRight}]];Map[Sow[{},#]&,Range[MBgetNumberOfReps[pGroup]]], Range[MBgetNumberOfReps[pGroup]]][[2]],1],{},2];
	lCovariants=MBmultiply[pGroup,lLeft,lRight];
	lres = MBgetYukawasFromList[Flatten[lCovariants[[1]]],pM,""];
   	If[Length[Flatten[pFlavon]]>0,
   		For[li = 1, li <= pOrder, li++,
   			 lCovariants=MBmultiply[pGroup,lCovariants,pFlavon];
             lres+=MBgetYukawasFromList[Flatten[lCovariants[[1]]], pY, li];
             ];
   	];
	Return[D[D[Simplify[lres],{lLeftVars}],{lRightVars}]];
];

MBgetMajoranaMassMatrix[pGroup_,pLeft_,pFlavon_,pOrder_:1,pM_:"m",pY_:"y"]:=Block[{lLeft,lLeftVars,lres,lCovariants,li},
	lLeft=Map[genLabels[MBgetDimensionOfRep[pGroup,#[[1]]],"pL"<>ToString[#[[2]]]<>"n"]&,Transpose[{pLeft,Range[Length[pLeft]]}]];
	lLeftVars=Flatten[lLeft];
	lLeft=DeleteCases[Flatten[Reap[Map[Sow[Apply[Sequence,#]]&,Transpose[{lLeft,pLeft}]];Map[Sow[{},#]&,Range[MBgetNumberOfReps[pGroup]]], Range[MBgetNumberOfReps[pGroup]]][[2]],1],{},2];
	lCovariants=MBmultiply[pGroup,lLeft,lLeft];
	lres = MBgetYukawasFromList[Flatten[lCovariants[[1]]],pM,""];
   	If[Length[Flatten[pFlavon]]>0,
   		For[li = 1, li <= pOrder, li++,
   			 lCovariants=MBmultiply[pGroup,lCovariants,pFlavon];
                         lres+=MBgetYukawasFromList[Flatten[lCovariants[[1]]], pY, li];
             ];
   	];
        lres=D[Simplify[lres],{lLeftVars,2}];
        For[li=1,li<=Length[lres],li++,lres[[li,li]]=lres[[li,li]]/2;];
	Return[lres];
];


MBconvertGAPToMathematica[pstr_]:=StringReplace[pstr,{"["->"{","]"->"}",RegularExpression["E\\((\\d+)\\)"]->"Exp[2*Pi*I/$1]" }];

ClearAll[replBrackets];
replBrackets[pstr_]:=StringReplace[pstr, {"{" -> "[", "}" -> "]"}];

MBconvertMathematicaToGAP[pstr_String] :=replBrackets[pstr];
MBconvertMathematicaToGAP[pA_List] := 
  replBrackets[ToString[Map[MBconvertMathematicaToGAP, pA]]];
MBconvertMathematicaToGAP[pA_Plus] := 
  replBrackets[ToString[Map[MBconvertMathematicaToGAP, pA]]];
MBconvertMathematicaToGAP[pA_] := Block[{larg, labs}, larg = Arg[pA];
   labs = Abs[pA];
   If[larg == 0, Return[ToString[labs]], 
    If[larg == \[Pi], Return[ToString[-labs]], 
      Return[StringJoin[ToString[labs], "*E(", 
        ToString[Simplify[2 \[Pi]/larg]], ")"]]];];];
        
   
generateKroneckerProduct[pGroup_,p_,q_]:=FullSimplify[Simplify[pGroup["CharacterTable"].Conjugate[pGroup["CharacterTable"][[p]]*pGroup["CharacterTable"][[q]]*pGroup["SizeConjugacyClasses"]]/pGroup["Size"]]];


readGAP[fname_]:=Block[{f,str},
	f=OpenRead[fname];
	str=StringJoin[Map[StringJoin[MBconvertGAPToMathematica[#],"\n"]&,ReadList[f,String]]];
	Close[fname];
	Return[str];
];

genTempName[]:=Block[{dl},
	dl=DateList[];
	dl[[6]]=Floor[1000*dl[[6]]];
	Return[Fold[Function[{x,y},x<>"-"<>ToString[y]],"Discrete",dl]];
	]


MonomialQ[pExpr_] := FreeQ[Expand[Map[(#/ExtractNumbers[#]) &, pExpr]], Plus]

SplitMonoPoly[{}]:={{},{}};
SplitMonoPoly[pOperators_]:=Block[{lres},
	lres=Simplify[GatherBy[pOperators,MonomialQ]];
	If[Length[lres]==2,
		Return[lres],
		If[MonomialQ[lres[[1,1]]],
			Return[Append[lres,{}]],
			Return[Prepend[lres,{}]]
		];
	];
];

ExtractNumbers[pExpr_List]:=Map[ExtractNumbers,pExpr];
ExtractNumbers[pExpr_Times]:=Map[ExtractNumbers,pExpr];
ExtractNumbers[pExpr_?NumericQ]:=pExpr;
ExtractNumbers[_]:=1;



NormalizeMonomial[pExpr_] :=pExpr/Norm[Map[ExtractNumbers, pExpr]] * Exp[-I * Arg[ExtractNumbers[First[Append[pExpr,1]]]]];
NormalizePolynomial[pExpr_] :=pExpr;(*/Norm[Map[ExtractNumbers, pExpr]];*)

ReduceMonomials[pExpr_]:=Union[DeleteCases[Simplify[Map[NormalizeMonomial,Simplify[pExpr]]],_?VectorZeroQ]];

ReducePolynomialUsingMonomial[pPoly_,pMono_]:=pPoly-Function[{a},a[[1]]/a[[2]]][First[SortBy[MapThread[Function[{x,y,z},{Coefficient[x,y],z}],{pPoly,ExtractMonomial[pMono],ExtractNumbers[pMono]}],Abs[#[[1]]]&]]]*pMono;

ReducePolynomialUsingMonomials[pPoly_,pMono_]:=NormalizePolynomial[Fold[ReducePolynomialUsingMonomial,pPoly,pMono]];

ReducePolynomials[pPoly_, pMono_] := 
 Union[DeleteCases[Simplify[
   Map[ReducePolynomialUsingMonomials[#, pMono] &, pPoly]],_?VectorZeroQ]];


ExtractAllMonomials[pExpr_Plus]:=Union[ExtractMonomial[Apply[List,pExpr]]];
ExtractAllMonomials[pExpr_?MonomialQ]:={ExtractMonomial[pExpr]};
ExtractMonomial[pExpr_List]:=Map[ExtractMonomial,pExpr];
ExtractMonomial[pExpr_Times]:=Map[ExtractMonomial,pExpr];
ExtractMonomial[_?NumericQ]:=1;
ExtractMonomial[pExpr_]:=pExpr;


GaussElimPolynomials[pPoly_] := 
  Block[{lMono, lPoly, lRes, lcomp, lScale},
   lRes = {};
   lPoly = pPoly;
   While[Length[lPoly] > 1,
    AppendTo[lRes, First[lPoly]];
    lPoly = Delete[lPoly, 1];
    lcomp = 1;
    lMono = 
     ExtractAllMonomials[
       Expand[Last[lRes][[lcomp]]]];
    While[Length[lMono] == 0,
     lcomp++;
     lMono = 
      ExtractAllMonomials[Expand[Last[lRes][[lcomp]]]];
    ];
	 While[VectorZeroQ[Map[Coefficient[#[[lcomp]], First[lMono]],lPoly]],
     	lMono=Delete[lMono,1];
         While[Length[lMono] == 0,
    	    lcomp++;
     	    lMono = ExtractAllMonomials[Expand[Last[lRes][[lcomp]]]];
     	 ];
     ];
    lRes[[-1]] = 
     lRes[[-1]]/Coefficient[Last[lRes][[lcomp]], First[lMono]];
    lPoly = 
     DeleteCases[
      FullSimplify[Simplify[
       Map[# - Coefficient[#[[lcomp]], First[lMono]]*Last[lRes] &, 
        lPoly]]], _?VectorZeroQ];
    ];
    Return[Join[DeleteCases[lRes,_?VectorZeroQ], lPoly]];
   ];

ReduceMonoPolySimple[{pSoMonomials_,pSoPolynomials_}]:=Block[{lRes,lSoMonomials,lSoPolynomials},
	lRes={};
	lSoMonomials=pSoMonomials;
	lSoPolynomials=pSoPolynomials;
	While[Length[lSoMonomials]>0,
		lSoMonomials=ReduceMonomials[lSoMonomials];
		lRes=Join[lRes,lSoMonomials];
		ltemp=ReducePolynomials[lSoPolynomials,lSoMonomials];
		{lSoMonomials,lSoPolynomials}=SplitMonoPoly[ltemp];
	];
	Return[Map[DeleteCases[#,_?VectorZeroQ]&,{lRes,lSoPolynomials}]];
];
						  
ReduceOperators[{}]:={};

ReduceOperators[pOperators_]:=Block[{ltemp,lSoMonomials,lSoPolynomials},
		{lSoMonomials,lSoPolynomials}=SplitMonoPoly[DeleteCases[pOperators,_?VectorZeroQ]];
		{lSoMonomials,lSoPolynomials}=ReduceMonoPolySimple[ReduceMonoPolySimple[{lSoMonomials,lSoPolynomials}]];
		lSoPolynomials=Map[NormalizePolynomial,lSoPolynomials];
		If[Length[lSoPolynomials]>1,
			lSoPolynomials=GaussElimPolynomials[lSoPolynomials];
			{ltemp,lSoPolynomials}=SplitMonoPoly[lSoPolynomials];
			{lSoMonomials,lSoPolynomials}=ReduceMonoPolySimple[{Join[lSoMonomials,ltemp],lSoPolynomials}];
		];
		Return[Simplify[Join[lSoMonomials,lSoPolynomials]]];
];

MBsimplifyCovariants[pOperators_]:=Map[ReduceOperators,pOperators];

VectorZeroQ[pExpr_] := Block[{lLen},
   lLen = Length[pExpr];
   If[lLen == 0, Return[False]];
   If[pExpr === ConstantArray[0,lLen], Return[True], Return[False]];
   ];


ExtractVars[pExpr_] := Block[{lres},
   lres =
    Union[Flatten[
      pExpr //. Power[lX_, _] -> lX //.
        Times[lX_, lY___] -> {lX, lY} //.
       Plus[lX_, lY___] -> {lX, lY}]];
   Return[DeleteCases[lres, _?NumberQ]];
   ];


mIndex[sq_,li_,lj_]:=(li-1)*sq+lj;

mTensorProduct[p_,q_]:=Block[{li,lj}, Return[Flatten[Table[Table[p[[li]]*q[[lj]],{lj,Length[q]} ],{li,Length[p]}],1]]];

pickTuple[sr_,sp_,sq_,Amat_,plstart_:0]:=Block[{li,lj,ll,lstatus},
	lstatus=True;
	ll=plstart;
	While[lstatus \[And] ll<sr,ll++;li=0;
		While[lstatus \[And] li<sp,li++;lj=0;
			While[lstatus \[And] lj<sq,lj++;
				If[Amat[[ll,ll]][[mIndex[sq,li,lj],mIndex[sq,li,lj]]]!=0,lstatus=False];
			]
		]
	];
	If[lstatus,Return[Null],Return[{li,lj,ll}]];
];

A[pGroup_,pr_,pp_,pq_,pl_,pk_]:=Block[{T,m,i,n,j},
				If[pGroup["NumericalEvaluate"],Return[Flatten[Table[Table[Flatten[Table[Table[FullSimplify[Simplify[Sum[N[MBgetRepMatrices[pGroup,pp][[T,m,i]]*MBgetRepMatrices[pGroup,pq][[T,n,j]]*Conjugate[MBgetRepMatrices[pGroup,pr][[T,pl,pk]]]],{T,MBgetSizeOfGroup[pGroup]}]*MBgetDimensionOfRep[pGroup,pr]/MBgetSizeOfGroup[pGroup]]],{j,MBgetDimensionOfRep[pGroup,pq]}],{i,MBgetDimensionOfRep[pGroup,pp]}]],{n,MBgetDimensionOfRep[pGroup,pq]}],{m,MBgetDimensionOfRep[pGroup,pp]}],1]],
				Return[Flatten[Table[Table[Flatten[Table[Table[FullSimplify[Simplify[Sum[MBgetRepMatrices[pGroup,pp][[T,m,i]]*MBgetRepMatrices[pGroup,pq][[T,n,j]]*Conjugate[MBgetRepMatrices[pGroup,pr][[T,pl,pk]]],{T,MBgetSizeOfGroup[pGroup]}]*MBgetDimensionOfRep[pGroup,pr]/MBgetSizeOfGroup[pGroup]]],{j,MBgetDimensionOfRep[pGroup,pq]}],{i,MBgetDimensionOfRep[pGroup,pp]}]],{n,MBgetDimensionOfRep[pGroup,pq]}],{m,MBgetDimensionOfRep[pGroup,pp]}],1]]];
			];

getC[sr_,sp_,sq_,l_,Amat_,plstart_:0]:=Block[{li,lj,lk,m,n},
{li,lj,lk}=pickTuple[sr,sp,sq,Amat,plstart];
Return[Flatten[Table[Table[Amat[[l,lk]][[mIndex[sq,m,n],mIndex[sq,li,lj]]],{n,sq}],{m,sp}]]]
];

CGC[pGroup_,p_,q_]:=Block[{ln,lA,lc,sp,sq,sr,lmulti,r,U,l,k,ll,li,lj,lk,lmn,lij},
			sp=MBgetDimensionOfRep[pGroup,p];
			sq=MBgetDimensionOfRep[pGroup,q];
			U={};
			For[r=1,r<=MBgetNumberOfReps[pGroup],r++,
				sr=MBgetDimensionOfRep[pGroup,r];
				lmulti=MBgetMultiplicity[pGroup,p,q,r];
			    lA=Table[Table[A[pGroup,r,p,q,l,k],{k,MBgetDimensionOfRep[pGroup,r]}],{l,MBgetDimensionOfRep[pGroup,r]}];
			    lk=0;
			    ln=1;
			    While[ln<=lmulti,
			    	lc=Table[getC[sr,sp,sq,ll,lA,lk],{ll,sr}];
			    	U=Append[U,lc];
			    	ln++;
			    	{li,lj,lk}=pickTuple[sr,sp,sq,lA,lk];
					lk+=1;
					];
			    ];
			Return[Transpose[Flatten[U,1]]];
			];

getCNormalized[sr_,sp_,sq_,l_,Amat_]:=Block[{li,lj,lk,m,n},
	{li,lj,lk}=pickTuple[sr,sp,sq,Amat];
	Return[Flatten[Table[Table[Amat[[l,lk]][[mIndex[sq,m,n],mIndex[sq,li,lj]]]/Sqrt[Amat[[lk,lk]][[mIndex[sq,li,lj],mIndex[sq,li,lj]]]],{n,sq}],{m,sp}]]]
];

CGCUnitary[pGroup_,p_,q_]:=Block[{ln,lAold,lAnew,lc,sp,sq,sr,lmulti,r,U,l,k,ll,lk,lmn,lij},
			sp=MBgetDimensionOfRep[pGroup,p];
			sq=MBgetDimensionOfRep[pGroup,q];
			U={};
			For[r=1,r<=MBgetNumberOfReps[pGroup],r++,
				sr=MBgetDimensionOfRep[pGroup,r];
				lmulti=MBgetMultiplicity[pGroup,p,q,r];
			    lAold=Table[Table[A[pGroup,r,p,q,l,k],{k,MBgetDimensionOfRep[pGroup,r]}],{l,MBgetDimensionOfRep[pGroup,r]}];
			    lc=ConstantArray[0,{sr,sp*sq}];
			    For[ln=1,ln<=lmulti,ln++,
			    	lAnew=Table[Table[lAold[[ll,lk]]-Table[Table[lc[[ll]][[lmn]] Conjugate[lc[[lk]][[lij]]],{lmn,sp*sq}],{lij,sp*sq}],{lk,sr}],{ll,sr}];
			   		lc=Table[getCNormalized[sr,sp,sq,ll,lAnew],{ll,sr}];
					U=Append[U,lc];
					lAold=lAnew;
					];
			    ];
			Return[Transpose[Flatten[U,1]]];
			];

decomposeTensorProduct[pGroup_,p_,q_,vec_]:=Block[{r,lres,ltemp,lvec,lmult,li,ldim,lred},
					  lres={};
					  lvec=vec;
					  For[r=1,r<=MBgetNumberOfReps[pGroup],r++,
					      lmult=MBgetMultiplicity[pGroup,p,q,r];
					      ltemp={};
					      ldim=MBgetDimensionOfRep[pGroup,r];
					      For[li=1,li<=lmult,li++,
						  lred=Take[lvec,ldim];
						  If[!VectorZeroQ[lred],ltemp=Append[ltemp,lred];];
						  lvec=Drop[lvec,ldim];
						  ];
					      lres=Append[lres,ltemp];
					      ];
					  Return[lres];
					  ];


genCoefficients[pLenList_, pHead_, pEnd_] := Block[{lf}, 
  Return[Table[(ToExpression["r"<>
    ToString[pHead] <> ToString[pEnd] <> "n" <> ToString[lf] ]+I ToExpression[
    "i"<>ToString[pHead] <> ToString[pEnd] <> "n" <> ToString[lf] ]), {lf, pLenList}]];];

genLabels[pLenList_, pHead_] := Block[{lf}, Return[Table[ToExpression[ToString[pHead] <> ToString[lf] ], {lf, pLenList}]];];


HC[pExpr_]:=Conjugate[pExpr];

plusHC[pExpr_]:=pExpr+HC[pExpr];

End[]; (* end of `Private`*)

EndPackage[];
